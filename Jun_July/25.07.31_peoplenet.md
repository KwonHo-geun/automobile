## Nvidia PeopleNet ì •ë¦¬


---
### ì‹¤ìŠµ ì •ë¦¬
<details> 
<summary>ë”ë³´ê¸°</summary>strong>
 1. ì…€ | ì‹œìŠ¤í…œ íŒ¨í‚¤ì§€ ì„¤ì¹˜

```

# APT ì¸ë±ìŠ¤ ê°±ì‹  í›„ í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜
apt update && apt install -y unzip wget ffmpeg
# ã†unzip  : NGC CLI ZIP ì••ì¶• í•´ì œìš©
# ã†wget   : ì›ê²© íŒŒì¼ ë‹¤ìš´ë¡œë“œ
# ã†ffmpeg : YouTube MP4 ì½”ë± í˜¸í™˜â€§í”„ë ˆì„ ì¶”ì¶œ

```

2. ì…€ | ì‘ì—… ë””ë ‰í„°ë¦¬ í™•ì¸

```

# í˜„ì¬ ë””ë ‰í„°ë¦¬(ì»¨í…Œì´ë„ˆ ê¸°ë³¸ ê²½ë¡œ) í™•ì¸
pwd      # ì˜ˆìƒ ì¶œë ¥: /workspace

```

3. ì…€ | ê¸°ì¡´ NGC CLI íƒìƒ‰

```
# ì´ë¯¸ NGC CLI ê°€ ì„¤ì¹˜ë˜ì–´ ìˆëŠ”ì§€ ê²€ìƒ‰
find /workspace -name "*ngc*" -type f
```

4. ì…€ | NGC CLI ë‹¤ìš´ë¡œë“œ

```
# NVIDIA ê³µì‹ ì‚¬ì´íŠ¸ì—ì„œ CLI ZIP ë°›ì•„ì˜¤ê¸°
wget -q https://ngc.nvidia.com/downloads/ngccli_reg_linux.zip
```

5. ì…€ | NGC CLI ì••ì¶• í•´ì œ

```
# ZIP íŒŒì¼ í’€ì–´ì„œ ./ngc-cli/ ë””ë ‰í„°ë¦¬ ìƒì„±
unzip ngccli_reg_linux.zip
```

6. ì…€ | Python ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜

```
# PeopleNet ì¶”ë¡  ë° YouTube ë‹¤ìš´ë¡œë“œìš© íŒŒì´ì¬ íŒ¨í‚¤ì§€
pip install onnxruntime yt-dlp opencv-python numpy
# ã†onnxruntime : ONNX ëª¨ë¸ ì¶”ë¡  ì—”ì§„
# ã†yt-dlp      : YouTube ì˜ìƒ ë‹¤ìš´ë¡œë“œ
# ã†opencv-python: í”„ë ˆì„ ì²˜ë¦¬Â·ì‹œê°í™”
# ã†numpy       : ìˆ˜ì¹˜ ì—°ì‚°
```

7. ì…€ | PeopleNet ë””ë²„ê·¸ ì‹¤í–‰

```
############################################################
# DebugNVIDIAPeopleNet í´ë˜ìŠ¤ ì •ì˜ ë° 5-í”„ë ˆì„ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ #
############################################################
import cv2, numpy as np, subprocess, os, onnxruntime as ort, yt_dlp

class DebugNVIDIAPeopleNet:
    def __init__(self):
        print("ğŸš€ ë””ë²„ê¹… NVIDIA PeopleNet ì‹œì‘...")
        # â‘  ëª¨ë¸ ê²½ë¡œ ë° í´ë˜ìŠ¤/ìƒ‰ìƒ ì •ì˜
        self.model_path = (
            "/workspace/peoplenet_vpruned_quantized_decrypted_v2.3.4/"
            "resnet34_peoplenet_int8.onnx"
        )
        self.classes = ['person', 'bag', 'face']
        self.colors  = [(0,255,0), (255,0,0), (0,0,255)]
        # â‘¡ ëª¨ë¸ ë¡œë“œ
        self.setup_model()

    # ---------------- ëª¨ë¸ ë¡œë“œ & ë”ë¯¸ ì¶”ë¡  ---------------- #
    def setup_model(self):
        print(f"ğŸ“ ëª¨ë¸ ê²½ë¡œ í™•ì¸: {self.model_path}")
        if not os.path.exists(self.model_path):
            return self._find_model()
        # CPUExecutionProvider â†’ í•„ìš”ì‹œ CUDAExecutionProvider ë¡œ ë³€ê²½
        self.session = ort.InferenceSession(
            self.model_path, providers=['CPUExecutionProvider']
        )
        self.input_name  = self.session.get_inputs()[0].name
        self.output_names = [o.name for o in self.session.get_outputs()]
        print("âœ… ëª¨ë¸ ë¡œë“œ ì™„ë£Œ, ë”ë¯¸ í…ŒìŠ¤íŠ¸ ì‹¤í–‰")
        self._test_inference()

    def _test_inference(self):
        dummy = np.random.randn(1,3,544,960).astype(np.float32)
        outs  = self.session.run(self.output_names, {self.input_name: dummy})
        for idx, o in enumerate(outs):
            print(f"  â†³ ì¶œë ¥{idx}: {o.shape}, ê°’ë²”ìœ„ [{o.min():.3f}, {o.max():.3f}]")

    # ------------------- ì „ì²˜ë¦¬ & ì¶”ë¡  -------------------- #
    def _preprocess(self, frame):
        f = cv2.resize(frame,(960,544))
        f = cv2.cvtColor(f, cv2.COLOR_BGR2RGB).astype(np.float32)/255.0
        f = np.transpose(f,(2,0,1))[None,...]     # (1,3,544,960)
        return f

    def detect(self, frame):
        inp = self._preprocess(frame)
        outs = self.session.run(self.output_names,{self.input_name: inp})
        return self._postprocess(outs[0], frame.shape)

    # ---------------- í›„ì²˜ë¦¬ (ì„ê³„ê°’+NMS) ------------------ #
    def _postprocess(self, pred, oshape):
        if pred.ndim==4: pred = pred[0]           # (3,34,60)
        H,W = oshape[:2]
        detections = []
        for cid, cname in enumerate(self.classes):
            grid = pred[cid]; thr=0.1
            ys,xs = np.where(grid>thr)
            for y,x in zip(ys[:5], xs[:5]):       # ìƒìœ„ 5ê°œë§Œ
                conf = float(grid[y,x])
                cx,cy = (x+0.5)/60, (y+0.5)/34
                bw,bh = (0.12,0.20) if cname=='person' else \
                        (0.06,0.08) if cname=='bag'    else (0.04,0.05)
                x1,y1 = int((cx-bw/2)*W), int((cy-bh/2)*H)
                x2,y2 = int((cx+bw/2)*W), int((cy+bh/2)*H)
                detections.append(
                    dict(bbox=[x1,y1,x2,y2], confidence=conf,
                         class_id=cid, class_=cname)
                )
        return detections

    # ------------------- ìœ íŠœë¸Œ ë‹¤ìš´ë¡œë“œ ------------------- #
    @staticmethod
    def download_mp4(url):
        out = "/workspace/debug_input_video.mp4"
        subprocess.run(["yt-dlp","-f","best[height<=720]","-o",out,url],
                       check=True)
        return out if os.path.exists(out) else None

# ---------------------- ëŸ°ì²˜ ----------------------------- #
def run_debug():
    dbg = DebugNVIDIAPeopleNet()
    video = dbg.download_mp4("https://www.youtube.com/watch?v=SzRzYvQq0aQ")
    cap = cv2.VideoCapture(video); frame_ids = [0,100,200,300,400]
    for fid in frame_ids:
        cap.set(cv2.CAP_PROP_POS_FRAMES,fid)
        ok,frame = cap.read();  print(f"\nğŸ¯ Frame {fid}")
        if ok:
            dets = dbg.detect(frame)
            for d in dets:
                print(f"  â†’ {d['class_']} {d['confidence']:.3f}")
    cap.release()

# 5ê°œ í”„ë ˆì„ ìƒ˜í”Œ ê²€ì¶œ ì‹¤í–‰
run_debug()

```

</strong></summary>
